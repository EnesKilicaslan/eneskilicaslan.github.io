{"pageProps":{"info":{"title":"Higher Order Components in React — (HOC)","date":"18.12.2021","excerpt":"Higher Order Components is a Javascript and React Pattern for code re-use","tags":["react","hoc","code-reuse","javascript"],"slug":"higher-order-components"},"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      strong: \"strong\",\n      ul: \"ul\",\n      li: \"li\"\n    }, _provideComponents(), props.components), {Image} = _components;\n    if (!Image) _missingMdxReference(\"Image\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"This might be relatively long, but keep up reading. I am sure you will find it useful.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Higher ordering is not special to ReactJS however React made the pattern famous. The idea comes from JavaScript's core feature closure.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"closure\"\n        }), \" is the ability to access the outer function's lexical scope, mainly the variables, from the inner function even after the outer function has completed its execution.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This concept becomes really powerful when it is combined with functions that return functions.\\nIn JavaScript, there two types of functions in terms of their order:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"first order functions:\"\n          }), \" Functions that take primitive or non-function types as parameters and return primitive or non-function type.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.strong, {\n            children: \"higher order functions:\"\n          }), \" Function that either take a function as a parameter or return a function.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Higher order functions and closure together creates magic in the event-based system we everyday use in the web. These concepts allow us to create reusable functions.\\nMDN guys explain it here in a very understandable way, take look if you haven't already.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"React inspired from JavaScript's Higher Order Functions, adopted it into their building blocks and created Higher Order Components (HOC).\\nHOC is a function that takes a React component as a parameter and returns a React component after adding some common logic. The goal here is the same, code reuse.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"When we find a common logic in React components, we can put that logic into a function. That function takes those components as a parameter and returns the enhanced version of the corresponding component after adding that logic.\\nMDN`s example is explanatory yet simple however applies only on Javascript.\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/images/hoc1.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The above code snipped works correctly. However there is a huge code duplication.\\nInstead of repeating the logic every time (in this case changing the font-size) like\\nabove, they created a function that returns another functions which handles the logic.\\nWe could get rid of code duplication with this way as shown below.\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/images/hoc2.png\",\n        width: 700,\n        height: 600\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Let's assume that we have a project and in that project we have custom Input and Textarea components wrapping html input and html textarea tags respectively.\\nMaking first letter of each word in their value capitalized is their feature. We can implement them as shown blow.\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/images/hoc3.png\",\n        width: 700,\n        height: 600\n      }), \"\\n\", _jsx(Image, {\n        src: \"/images/hoc4.png\",\n        width: 700,\n        height: 600\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"As you realized, there is a code duplication for the keep tracking the value in the state and capitalizing work. Even, the code seems very similar from the constructor to render methods. We can get rid of this duplication by moving the logic to a higher order function as shown below.\"\n      }), \"\\n\", _jsx(Image, {\n        src: \"/images/hoc5.png\",\n        width: 700,\n        height: 600\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We created a function named withCounter, this is the HOC convention; we add with prefix to the function name. This function takes a component — in this case it will be either Input or Textarea components and returns its enhanced version after adding capitalizing logic.\\nThen we can simplify our Input component as show below.\\nIt does not need to keep a state and have a capitalizing logic anymore, instead it takes those information from the props. The last line is important,\\nwe don't just export the Input component, but we export its enhanced version by wrapping it the \", _jsx(_components.strong, {\n          children: \"withCounter\"\n        }), \" HOC function.\"]\n      }), \"\\n\", _jsx(Image, {\n        src: \"/images/hoc6.png\",\n        width: 700,\n        height: 600\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I didn't put Textarea component here to make the post a bit shorter, you can take a look to the sandbox\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"That's all for this post. You can find the sandbox here if you want play around a bit.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Hope you learned a lot and found this post useful.\\nIf you did, please don't forget to leave claps and share. Thanks in advance, see you in the next posts.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}